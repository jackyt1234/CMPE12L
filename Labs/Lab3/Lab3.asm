;Robert Loquinario
;CMPE12L
;Section B TA: Max
;Lab3: Decimal Converter

;R0 = User_Char
;R1 = This_Digit
;R2 = Neg_Flag
;R3 = User_Int
;R4 = ancillary register

	.ORIG x3000
	LEA  R0, GREET		;Greeting
	PUTS

START:
	LEA R0, PROMPT
	PUTS
	AND R0,R0,0		;Set all vars to zero
	AND R1,R0,0
	AND R2,R0,0


GET_USER_CHAR			;Get a char and store in R0
	GETC
	OUT
	LD R4, MINUS		;LOAD '-' INTO R4
	ADD R4, R4, R0 		;CHECK IF INPUT WAS '-'
	BRz SET_NEG_FLAG	;IF SO GO TO SET_NEG_FLAG
				;Check to see if user char is "X"
	LD  R4, X
	ADD R4, R0, R4		;CHECK if X
	BRz EXIT		;EXIT PROGRAM
	LD  R4, NL		;LOAD '\n' INTO R4
	ADD R4, R0, R4		;CHECK IF NEW LINE
	BRz CONVERT		;IF SO CONVERT TO BINARY
	LD R4, NZERO		;LOAD NEG '0' INTO R4
	ADD R0, R0, R4		;IF NOT SUBTRACT '0' TO GET ACTUAL BINARY NUMBER
	BRnzp UPDATE_INT	;UPDATE_INT REGARDLESS 

UPDATE_INT
	ADD R3, R1, 0		;SET UP MULT BY STORING R1 VALUE INTO R3
	AND R4, R4, 0		;SET R4 TO 0
	ADD R4, R4, 9		;0-9 (R4 = COUNTER, LOOP 10 TIMES)
	JSR MULTIPLICATION	;JUMP TO THIS SUBROUTINE AND COME BACK WHEN 'RET' 
	ADD R1, R1, R0		
	BRnzp GET_USER_CHAR

MULTIPLICATION
	BRz RETURN		;GO HERE TO ENTER MORE THAN ONE CHAR/DIGIT
	ADD R1, R1, R3		;INT = INT*(10) + DIGIT
	ADD R4, R4, -1		;1-10 for INT*(10)
	BRp MULTIPLICATION	;MULTIPLY TILL R4=0

RETURN
	LD R3, 0		;LOAD 0 INTO R3
	LD R4, 0		;LOAD 0 INTO R4 BEFORE GOING BACK TO GET_USER_CHAR
	RET			;RETURN BACK TO FINISH UPDATE_INT

SET_NEG_FLAG
	ADD R2,R2, 1		;SET NEG_FLAG TO 1 TO SIGNIFY 2'SC
	BRnzp GET_USER_CHAR	;GET NEXT CHAR

CONVERT
	LEA R0, HERE		;do 2'sc and then startover
	PUTS
	AND R0, R0, 0 
	ADD R2,R2,0		;if this is 0 then no 2'sC
	BRp TWOSCOMPLEMENT
	BRnz BINARYCONVERSION
	BRnzp START
TWOSCOMPLEMENT
	ADD R2, R2, -1
	BRn BINARYCONVERSION	;FLAG != 1 (1 < 0 = FALSE )
	NOT R1, R1		;INVERT
	ADD R1, R1, 1		; ADD 1 

BINARYCONVERSION
	LEA R4, MASK		;PUT MASK INTO R4
	AND R2, R2, 0		;FLAG =0
	ADD R2, R2, 15		;MASK = 1ST MASK ADDRESS (COUNT = 15)
	LD R5, ZERO		;0 IN THE 16 BIT STRING
GOMASK
	BRn START		;IF COUNT <0, GO TO THIS PROCEDURE
	LDR R3, R4, 0		;PUTS MASK VALUE AT THAT ADDRESS TO R3
	AND R0, R1, R3		;AND THE 16 MASKS, AND FIND 1 WHEN IT MATCHES
	BRz DISPLAY		;IF DIGIT == 0, DISPLAY
	AND R0,R0, 0
	ADD R0, R0, 1

DISPLAY
	ADD R0, R0, R5		;BINARY STRING
	OUT			;PRINT STRING
	ADD R4, R4, 1		;STORE ADDRESS OF NEXT MASK
	ADD R2, R2, -1		;DECREMENT AMOUNT OF MASKS
	BRnzp GOMASK		;KEEP PRINTING
	
EXIT
	LEA R0, BYE		;LOAD BYE INTO R0
	PUTS			;PRINT
	HALT			;END

HALT

;FILLS

MINUS	.FILL	-45		;Negative of ASCII '-'
X	.FILL	-88		;Negative of ASCII 'X'
ZERO	.FILL 	48		;zero
NZERO	.FILL	-48		;neg of zero
NL	.FILL	-10		;NEG OF NEW LINE	

;STRINGS

GREET	.STRINGZ "Welcome to the conversion program!"
PROMPT	.STRINGZ "\nEnter a decimal number or 'X' to quit:\n"
HERE	.STRINGZ "Thanks, here it is in binary\n"
BYE	.STRINGZ "\nBye. Have a great day."
THANKS	.STRINGZ "Thanks, here it is in binary:\n"

MASK	.FILL x8000
	.FILL x4000
	.FILL x2000
	.FILL x1000
	.FILL x0800
	.FILL x0400
	.FILL x0200
	.FILL x0100
	.FILL x0080
	.FILL x0040
	.FILL x0020
	.FILL x0010
	.FILL x0008
	.FILL x0004
	.FILL x0002
	.FILL x0001
.END